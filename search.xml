<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Apple企业开发者账号打包ipa]]></title>
    <url>%2F2017%2F06%2F21%2FApple%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%89%93%E5%8C%85ipa%2F</url>
    <content type="text"><![CDATA[一:肯定要有企业开发者账号,没有的先自行申请,如果你已经有一个有效的账号继续往下看二:在开发者账号中心创建Certificates 和 Profiles 1.创建Certificates 由于已经创建过该类证书，所以不能再次创建。点击continue后会要求上传证书请求文件,制作方法如下1231.打开dock的Launchpad，在其他中找到“钥匙串访问”，在左上方导航条中选择“钥匙串访问”目录下的“证书助理”，选择“从证书颁发机构请求证书”2.得到如下界面(填写邮件地址,选择存储到磁盘),点击继续3.把证书保存到存储桌面.点击存储 点击choosefile,选择刚刚放到桌面上的钥匙串文件(.certSigningRequest),然后点击Generate,最后点击download下载到本地,双击运行即可.2.创建Identifiers 写入name和bundle id,选择必要的app server 预览,确认后点击Register,下一页点击Done即可 3.创建Provisioning Profiles 用 Certificate.去创建发布版本 选择上一步的Identifier 选择第一步的Certificates 输入name 下载Profiles 双击运行上面两个文件三:在项目中配置Certificates 和 Profiles1.Xcode 中登录开发者账号Apple Id2.点击PROJECT –&gt; Build Setterings –&gt; 对应选择Profile和证书,账号 3.点击TARGETS –&gt; Build Setterings –&gt; 对应选择Profile和证书,账号 4.点击Project –&gt; Edit Scheme –&gt; 修改为Release 5.把运行设备改为真机或者Generic iOS Deveice6.点击Project –&gt; Archive –&gt; 右侧Export 7.选取当前开发号 –&gt; Chooese 8.选择Export one app –&gt;next,加载完成后生成在桌面的文件夹中,完事~遇到任何问题欢饮私信或评论]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Apple企业开发者账号</tag>
        <tag>证书， 打包上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift / Objective_C / Xcode实际开发中可能遇到的小功能小技巧总结]]></title>
    <url>%2F2017%2F06%2F21%2FSwift-Objective-C-Xcode%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一:Swift3.0为视图添加旋转动画,效果如下: 代码实现: 123456789//创建动画let anim = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)//设置相关属性anim.toValue = 2 * M_PIanim.repeatCount = MAXFLOATanim.duration = 15//完成之后不移除,testView被释放,动画随着一起删除anim.isRemovedOnCompletion = false testView(anim, forKey: nil) 二:解决项目中每次界面跳转隐藏TabBar的问题思路:在UINavigationController 中重写pushViewController 方法,不必每次跳转都调用hidesBottomBarWhenPushed1234567override func pushViewController(_ viewController: UIViewController, animated: Bool) &#123; //隐藏tabbar if childViewControllers.count &gt; 0 &#123; viewController.hidesBottomBarWhenPushed = true &#125; super.pushViewController(viewController, animated: animated)&#125; 三:Swift3.0中使用NSLayoutConstraint为控件添加约束12345678//设置通过代码添加Constraint,否则View还是会按照以往的autoresizingMask进行计算centerButton.translatesAutoresizingMaskIntoConstraints = false//依次添加X,Y, W,Hview.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .centerX, relatedBy: .equal, toItem: self.view, attribute: .centerX, multiplier: 1.0, constant: 0))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .centerY, relatedBy: .equal, toItem: self.view, attribute: .centerY, multiplier: 1.0, constant: -60))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 50))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 50)) 方法解读:在view视图中,为参数1添加约束设置 参数1(一般为视图) 的 参数2(坐标或宽高) 属性 参数3(大于等于小鱼) 参数4(参照视图) 的 参数5(坐标或宽高) 属性 乘以 参数6 加上 参数7注意:单纯设置宽高的时候,参数4传入nil,参数5传入.notAnAttribute1view.addConstraint(NSLayoutConstraint(item: 参数1, attribute: 参数2, relatedBy: 参数3, toItem: 参数4, attribute: 参数5, multiplier: 参数6, constant: 参数7)) 四:Swift3.0通过十六进制值设置UIColor1234567891011extension UIColor &#123; class func colorWithHex(hexValue: UInt32) -&gt; UIColor &#123; let r = (hexValue &amp; 0xff0000) &gt;&gt; 16 let g = (hexValue &amp; 0x00ff00) &gt;&gt; 8 let b = hexValue &amp; 0x0000ff return UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: 1.0) &#125;&#125;//示例调用:view.backGroundColor = UIColor.colorWithHex(hexValue: 0xff0000) 五:Swift3.0中&amp;error的写法12var error: NSError?context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) 六:动态设置TableView的滑动范围12345- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //一般获取最后控件的最大Y坐标,labelExplain是最后一个cell下追加的控件 self.tableView.contentSize = CGSizeMake(0,CGRectGetMaxY(self.labelExplain.frame) + 10);&#125; 七:clipstobounds与maskstobounds的区别12345clipsToBounds(UIView)是指视图上的子视图,如果超出父视图的部分就截取掉masksToBounds(CALayer)却是指视图的图层上的子图层,如果超出父图层的部分就截取掉 八:查看真机沙盒文件夹,查看真机崩溃日志 九:常用的路径位置1234567891011121314模拟器的位置:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置:/Applications/Xcode.app/Contents/Developer/Documentation/DocSets插件保存路径:~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins自定义代码段的保存路径:~/Library/Developer/Xcode/UserData/CodeSnippets/ //如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。描述文件路径~/Library/MobileDevice/Provisioning Profiles 十:富文本和HTML字符串互相转化12345678910111213//富文本转html字符串- (NSString *)attriToStrWithAttributeString:(NSAttributedString *)attributeString&#123; NSDictionary *tempDic = @&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute:[NSNumber numberWithInt:NSUTF8StringEncoding]&#125;; NSData *htmlData = [attributeString dataFromRange:NSMakeRange(0, attributeString.length) documentAttributes:tempDic error:nil]; return [[NSString alloc] initWithData:htmlData encoding:NSUTF8StringEncoding];&#125;//html字符串转富文本- (NSAttributedString *)strToAttriWithString:(NSString *)htmlString&#123; return [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType&#125; documentAttributes:nil error:nil];&#125; 十一:Swift项目中引入Objective_C三方框架后手动桥接的方法1&gt;手动创建一个.h的文件,比如:Demo-Bridge.h2&gt;在Build Setteings 中找到 Objective_C Bridging Header 添加路径$(SRCROOT)/Demo/Demo-Bridge.h3&gt;包含Objective_C头文件,例如:#import &quot;UIView+WebCache.h&quot;十二:UITableView多行选择修改系统默认选择样式在自定义的cell中重写layoutSubviews12345678910111213141516171819202122- (void)layoutSubviews&#123; [super layoutSubviews]; // 设置UITableViewCellEditControl样式 for (UIControl *control in self.subviews) &#123; if ([control isMemberOfClass:NSClassFromString(@&quot;UITableViewCellEditControl&quot;)]) &#123; for(UIView *view in control.subviews) &#123; if([view isKindOfClass: [UIImageView class]]) &#123; UIImageView *img = (UIImageView *)view; if(self.selected) &#123; //选择状态图片 img.image= [UIImage imageNamed:@&quot;image1&quot;]; &#125; else &#123; //未选中状态图片 img.image= [UIImage imageNamed:@&quot;image2&quot;]; &#125; &#125; &#125; &#125; &#125;&#125; 十三:Xcode项目中一键替换项目中所有类中指定文字或代码1&gt;快捷键command + shift + F唤醒全局搜索并进入输入状态2&gt;切换Find为Replace(这里也可以采用正则进行查找搜索Regular Expression) 3&gt;输入要搜索的内容和替换结果,然后点击Replace All即可 十四:NSUserDefaults判断应用程序是否是安装完首次次启动123456if (![[NSUserDefaults standardUserDefaults] valueForKey:@&quot;FirstStart&quot;]) &#123; [[NSUserDefaults standardUserDefaults] setValue:@&quot;firstStart&quot; forKey:@&quot;FirstStart&quot;]; //第一次启动,可以设置欢迎页或者设置默认语言&#125; else &#123; //非第一次启动&#125; 十五:Swift 设置在debug模式下打印日志,并且锁定代码位置(Objective_C打印设置)1234567891011// 可以把下列代码放在AppDelegate的@UIApplicationMain的上方func DebugLog&lt;T&gt;(messsage : T, file : String = #file, funcName : String = #function, lineNum : Int = #line) &#123; #if DEBUG let fileName = (file as NSString).lastPathComponent print(&quot;\(fileName):(\(lineNum))-\(messsage)&quot;) #endif&#125;//使用方法DebugLog(messsage: &quot;test&quot;)//输出类名 + 代码行数 + 输出信息ViewController.swift:(37)-test 十六:修改默认开发语言(Xcode默认开发语言是英语)1&gt;先添加英语之外的一种语言 2&gt;Show in Finder工程文件 –&gt; 显示包内容 –&gt; 用文本打开project.pbxproj –&gt; 搜索developmentRegion –&gt; 将值改为zh-Hans 3&gt;修改成功十七:使用runtime为分类添加属性我们知道系统的UITableView的section和row属性，就是定义在NSIndexPath的分类里的 示例方法:123456789101112131415161718//写一个UIView的分类命名:UIView+CategoryUIView+Category.h//增加的属性@property (nonatomic, strong) NSObject *propertyTest;UIView+Category.m//加入运行时头文件#import &lt;objc/runtime.h&gt;@implementation UIView (Category)//获取关联的对象- (NSObject *)propertyTest &#123; return objc_getAssociatedObject(self, @selector(propertyTest));&#125;//给对象添加关联对象- (void)setPropertyTest:(NSObject *)value &#123; objc_setAssociatedObject(self, @selector(propertyTest), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;此后,就可以正常访问了该属性了 十八:App迭代开发版本号的规则0&gt;首先我们的App第一版本首次上线, 比如以1.0.0为首次上线的版本号1&gt;上线后突然发现一个严重的Bug那我们就要修复更新版本, 此时我们的版本号为1.0.1, 所以说如果修复Bug或者优化功能, 我们只修改叠加第三位数字, 其他不变2&gt;如果有了新的需求, 在原来的基础上增加了一个新功能, 那么我们的版本号变为1.1.0, 需要清空第三位数字为0, 来叠加修改第二位数字3&gt;如果App需求功能大改, 更新量非常大, 那我们的版本号变为2.0.0, 需要叠加修改第一位数字, 清空其他数字为0十九:Swift中懒加载先说说OC中的懒加载,通常是写get方法,例如:12345678- (DataModel *)model&#123; if (!_model) &#123; _model = [[DataModel alloc] init]; _model.title = @&quot;标题&quot;; &#125; return _model;&#125; swift中有专门的懒加载修饰符lazy,实现如下:12345private lazy var model: DataModel = &#123; let model = DataModel() model.title = &quot;标题&quot; return model&#125;() 二十:Swift中shouldAutorotate的重写123456789override open var shouldAutorotate: Bool &#123; return false / true&#125;//或者open override var shouldAutorotate: Bool &#123; get &#123; return false / true &#125;&#125; 二十一:屏幕旋转的时候状态栏显示问题如果是在视图View中,重写layoutSubviews;如果是在ViewController中重写viewWillLayoutSubviews,Swift代码如下:12345678910//视图控制器中override func viewWillLayoutSubviews() &#123; super.viewWillLayoutSubviews() UIApplication.shared.isStatusBarHidden = false&#125;//视图中override func layoutSubviews() &#123; super.layoutSubviews() UIApplication.shared.isStatusBarHidden = false&#125; 二十二:区分==,isEqual,isEqualToString==: 比较的是内存地址isEqual: 是 NSObject 的方法,首先都会判断指针是否相等 ,相等直接返回YES,不相等再判断是否是同类对象或非空,空或非同类对象直接返回NO,而后依次判断对象对应的属性是否相等,若均相等,返回YESisEqualToString: 是NSString的方法,从继承关系角度来说是 isEqual的衍生方法,在都是字符串的前提下,判断字符串的内容是否相等,如果知道了两个对象都是字符串,isEqualToString比isEqual要快二十三:修改GitHub项目显示语言1234567891011121314打开Terminal 进入到仓库文件夹$:cd /Users/MacName/Desktop/Demo创建一个`.gitattributes`的文件$:touch .gitattributes打开文件$:open .gitattributes写入如下代码,比如设置语言为Swift*.h linguist-language=swift*.m linguist-language=swift重新push项目到GitHub, 完成修改 二十四:Terminal命令查看系统隐藏文件1234567显示隐藏文件:$:defaults write com.apple.finder AppleShowAllFiles -bool true关闭显示隐藏文件:defaults write com.apple.finder AppleShowAllFiles -bool false***执行命令后需要打开强制退出界面(快捷键option+command+esc),重启Finder 二十五:Masonry布局后获取Frame值需要立即更新子视图的布局后获取即可1[self layoutIfNeeded]; 二十六:Xcode同时打开两个Simulator模拟器(做通信APP方便调试)打开终端进到xcode路径下的Applications路径1$:cd /Applications/Xcode.app/Contents/Developer/Applications/ 打开模拟器1$:open -n Simulator.app/ 或者执行一个脚本也可以,创建文件xim.sh,键入以下代码1234#!/bin/shcd /Applications/Xcode.app/Contents/Developer/Applications/open -n Simulator.app/ 1sudo sh sim.sh 会有如下提示: 点击OK后,换一个与当前模拟器设备不同的机型 然后在Xcode中选择刚选取的机型run包即可同时打开调试实际上多开别的APP道理也是一样的,进到APP应用目录,open -n appName.app/即可二十七:TableView检测滑动到底部和顶部(可用于聊天界面取历史消息)1234567891011121314- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y == scrollView.contentSize.height - scrollView.frame.size.height) &#123; NSLog(@&quot;滑到底部加载更多&quot;); &#125; if (scrollView.contentOffset.y == 0) &#123; NSLog(@&quot;滑到顶部更新&quot;); &#125;&#125;// 另外点击状态栏会调用- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123; NSLog(@&quot;点击状态栏调用&quot;);&#125; 二十八:区分__weak,__unsafe_unretained,__block123__weak 在释放指针后能够同时将指针置为nil__unsafe_unretained 只留下一个无效的也指针__block 打破循环 copy副本 内部修改]]></content>
      <categories>
        <category>iOS_Objective-C</category>
        <category>iOS_Swift</category>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
        <tag>Xcode</tag>
        <tag>GitHub</tag>
        <tag>开发小技巧、小功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS音频开发(录音+播放+剪辑+合成+压缩转码)]]></title>
    <url>%2F2017%2F06%2F21%2FiOS%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91-%E5%BD%95%E9%9F%B3-%E6%92%AD%E6%94%BE-%E5%89%AA%E8%BE%91-%E5%90%88%E6%88%90-%E5%8E%8B%E7%BC%A9%E8%BD%AC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[录音: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//音频会话AVAudioSession *session = [AVAudioSession sharedInstance];NSError *sessionError;/*AVAudioSessionCategoryPlayAndRecord :录制和播放AVAudioSessionCategoryAmbient :用于非以语音为主的应用,随着静音键和屏幕关闭而静音.AVAudioSessionCategorySoloAmbient :类似AVAudioSessionCategoryAmbient不同之处在于它会中止其它应用播放声音。AVAudioSessionCategoryPlayback :用于以语音为主的应用,不会随着静音键和屏幕关闭而静音.可在后台播放声音AVAudioSessionCategoryRecord :用于需要录音的应用,除了来电铃声,闹钟或日历提醒之外的其它系统声音都不会被播放,只提供单纯录音功能.*/[session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;sessionError];[session setActive:YES error:nil];// 录音参数NSDictionary *setting = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kAudioFormatLinearPCM], AVFormatIDKey,// 编码格式 [NSNumber numberWithFloat:8000], AVSampleRateKey, //采样率 [NSNumber numberWithInt:2], AVNumberOfChannelsKey, //通道数 [NSNumber numberWithInt:16], AVLinearPCMBitDepthKey, //采样位数(PCM专属) [NSNumber numberWithBool:NO], AVLinearPCMIsNonInterleaved, //是否允许音频交叉(PCM专属) [NSNumber numberWithBool:NO],AVLinearPCMIsFloatKey, //采样信号是否是浮点数(PCM专属) [NSNumber numberWithBool:NO], AVLinearPCMIsBigEndianKey, //是否是大端存储模式(PCM专属) [NSNumber numberWithInt:AVAudioQualityMax], AVEncoderAudioQualityKey, //音质 nil];self.audioRecorder.delegate = self;//开启音频测量self.audioRecorder.meteringEnabled = YES;//保存路径self.audioRecorder = [[AVAudioRecorder alloc] initWithURL:[NSURL URLWithString:filePath] settings:setting error:nil];//准备 / 开始录音[self.audioRecorder prepareToRecord];[self.audioRecorder record];//暂停录音[self.audioRecorder pause];//停止录音[self.audioRecorder stop];//删除录音//AVAudioRecorderDelegate//when a recording has been finished or stopped. This method is NOT called if the recorder is stopped due to an interruption.(录音完成)- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag;//if an error occurs while encoding it will be reported to the delegate(编码发生错误)- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)recorder error:(NSError * __nullable)error;//when the audio session has been interrupted while the recorder was recording. The recorded file will be closed.(被打断)- (void)audioRecorderBeginInterruption:(AVAudioRecorder *)recorder NS_DEPRECATED_IOS(2_2, 8_0);//when the audio session interruption has ended and this recorder had been interrupted while recording(被打断结束)- (void)audioRecorderEndInterruption:(AVAudioRecorder *)recorder withOptions:(NSUInteger)flags NS_DEPRECATED_IOS(6_0, 8_0); 播放123456789101112131415161718192021222324252627282930313233343536373839AVAudioSession *session = [AVAudioSession sharedInstance];NSError *sessionError;[session setCategory:AVAudioSessionCategoryPlayback error:&amp;sessionError];[session setActive:YES error:nil];//开启接近监视(靠近耳朵的时候听筒播放,离开的时候扬声器播放)[[UIDevice currentDevice] setProximityMonitoringEnabled:YES];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sensorStateChange:)name:UIDeviceProximityStateDidChangeNotification object:nil];self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL URLWithString:filePath] error:nil];self.audioPlayer.delegate = self;//准备播放 / 播放[self.audioPlayer prepareToPlay];[self.audioPlayer play];//停止播放[self.audioPlayer stop];//暂停播放[self.audioPlayer pause];//proximityStateChange:(NSNotificationCenter *)notification方法if ([[UIDevice currentDevice] proximityState] == YES) &#123; //靠近耳朵 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];&#125; else &#123; //离开耳朵 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:nil];&#125;//AVAudioPlayerDelegate//when a sound has finished playing. This method is NOT called if the player is stopped due to an interruption(播放完成)- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag;//if an error occurs while decoding it will be reported to the delegate.(解码结束)- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError * __nullable)error;//when the audio session has been interrupted while the player was playing. The player will have been paused(被打断)- (void)audioPlayerBeginInterruption:(AVAudioPlayer *)player NS_DEPRECATED_IOS(2_2, 8_0);//when the audio session interruption has ended and this player had been interrupted while playing(被打断结束)- (void)audioPlayerEndInterruption:(AVAudioPlayer *)player withOptions:(NSUInteger)flags NS_DEPRECATED_IOS(6_0, 8_0); 剪辑将路径filePath下的音频文件从time截取到time2后在resultPath中输出123456789101112//AVURLAsset是AVAsset的子类,AVAsset类专门用于获取多媒体的相关信息,包括获取多媒体的画面、声音等信息.而AVURLAsset子类的作用则是根据NSURL来初始化AVAsset对象.AVURLAsset *videoAsset = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:filePath]];//音频输出会话//AVAssetExportPresetAppleM4A: This export option will produce an audio-only .m4a file with appropriate iTunes gapless playback data(输出音频,并且是.m4a格式)AVAssetExportSession *exportSession = [AVAssetExportSession exportSessionWithAsset:videoAsset presetName:AVAssetExportPresetAppleM4A];//设置输出路径 / 文件类型 / 截取时间段exportSession.outputURL = [NSURL fileURLWithPath:resultPath];exportSession.outputFileType = AVFileTypeAppleM4A;exportSession.timeRange = CMTimeRangeFromTimeToTime(CMTimeMake(time1, 1), CMTimeMake(time2, 1));[exportSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 合成将路径filePath1和路径filePath2下的音频合成12345678910111213141516171819//AVURLAsset子类的作用则是根据NSURL来初始化AVAsset对象.AVURLAsset *videoAsset1 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath1] options:nil];AVURLAsset *videoAsset2 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath2] options:nil];//音频轨迹(一般视频至少有2个轨道,一个播放声音,一个播放画面.音频有一个)AVAssetTrack *assetTrack1 = [[videoAsset1 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];AVAssetTrack *assetTrack2 = [[videoAsset2 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];//AVMutableComposition用来合成视频或音频AVMutableComposition *composition = [AVMutableComposition composition];AVMutableCompositionTrack *compositionTrack = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];// 把第二段录音添加到第一段后面[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset1.duration) ofTrack:assetTrack1 atTime:kCMTimeZero error:nil];[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset2.duration) ofTrack:assetTrack2 atTime:videoAsset1.duration error:nil];//输出AVAssetExportSession *exporeSession = [AVAssetExportSession exportSessionWithAsset:composition presetName:AVAssetExportPresetAppleM4A];exporeSession.outputFileType = AVFileTypeAppleM4A;exporeSession.outputURL = [NSURL fileURLWithPath:resultPath];[exporeSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 压缩转码下载LAME (Lame Aint an MP3 Encoder) 双击解压后放到一个文件夹下,文件夹需要命名为lame,否则无法生成.h和.a文件使用Terminal进入该文件夹,编译生成静态库,脚本代码1234567$:cd cd /Users/mac/Desktop/lame//创建build_lame.sh$:touch build_lame.sh//打开build_lame.sh,粘贴脚本代码$:open build_lame.sh//编译执行脚本,生成静态库,需要输入本机密码$:sudo sh build_lame.sh 将fat-lame文件夹下的include文件夹和lib文件夹放入工程,再写一个OC的类调用lame.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@try &#123; int read, write; FILE *pcm = fopen([filePath cStringUsingEncoding:1], &quot;rb&quot;);//被转换的音频文件位置 fseek(pcm, 4*1024, SEEK_CUR); FILE *mp3 = fopen([resultPath cStringUsingEncoding:1], &quot;wb&quot;);//生成的Mp3文件位置 const int PCM_SIZE = 8192; const int MP3_SIZE = 8192; short int pcm_buffer[PCM_SIZE*2]; unsigned char mp3_buffer[MP3_SIZE]; // 初始化lame编码器 lame_t lame = lame_init(); // 设置lame mp3编码的采样率 / 声道数 / 比特率 lame_set_in_samplerate(lame, 8000); lame_set_num_channels(lame,2); lame_set_out_samplerate(lame, 8000); lame_set_brate(lame, 8); // MP3音频质量.0~9.其中0是最好,非常慢,9是最差. lame_set_quality(lame, 7); // 设置mp3的编码方式 lame_set_VBR(lame, vbr_default); lame_init_params(lame); do &#123; size_t size = (size_t)(2 * sizeof(short int)); read = fread(pcm_buffer, size, PCM_SIZE, pcm); if (read == 0) &#123; write = lame_encode_flush(lame, mp3_buffer, MP3_SIZE); &#125; else &#123; write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, MP3_SIZE); &#125; fwrite(mp3_buffer, write, 1, mp3); &#125; while (read != 0); lame_close(lame); fclose(mp3); fclose(pcm);&#125;@catch (NSException *exception) &#123; NSLog(@&quot;%@&quot;,[exception description]);&#125;@finally &#123; // 转码完成 return resultPath;&#125; 基本上可以将100K左右的录音文件压缩到10K以下]]></content>
      <categories>
        <category>iOS_Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>音频开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步教你理解和实现iOS中的链式编程和函数式编程]]></title>
    <url>%2F2017%2F06%2F21%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E7%8E%B0iOS%E4%B8%AD%E7%9A%84%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谈到链式编程和函数式编程,那Masonry几乎就是最经典的代表.如:1make.top.equalTo(self.view).offset(60) 像这样top.equalTo(self.view).offset(60)通过”点”语法，将需要执行的代码块连续的书写下去,就是链式编程.它能使代码简单易读，书写方便像这样equalTo(self.view)通过’()’去调用函数,一般调用完返回的还是这个对象本身,就是函数式编程. 1.传统写法,两个方法需要单独调用,也不能任意组合顺序创建Person类123456789101112131415Person.h:- (void)eat1;- (void)sleep1;Person.m:- (void)eat1&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;- (void)sleep1&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; 控制器中调用Person类中方法12345ViewController.m:Person *person = [[Person alloc] init];[person eat1];[person sleep1]; 2.用’[]’实现连续调用12345678910111213141516171819202122Person.h:- (Person *)eat2;- (Person *)sleep2;Person.m:- (Person *)eat2&#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self;&#125;- (Person *)sleep2&#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self;&#125;ViewController.m:[[person eat2] sleep2];[[person sleep2] eat2]; 3.用’()”实现函数式编程,用block实现1234567891011121314151617181920212223242526Person.h:- (void (^)())eat3;- (void (^)())sleep3;Person.m:- (void (^)())eat3&#123; //定义block void (^eat3Block)() = ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); &#125;; return eatBlock;&#125;- (void (^)())sleep3&#123; return ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); &#125;;;&#125;ViewController.m:person.eat3();person.sleep3(); 4.实现函数式 + 链式(无参)12345678910111213141516171819202122232425262728Person.h:- (Person * (^)())eat4;- (Person * (^)())sleep4;Person.m:- (Person *(^)())eat4&#123; Person * (^eat4Block)() = ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self; &#125;; return eat4Block;&#125;//上下两种写法一样- (Person *(^)())sleep4&#123; return ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self; &#125;;&#125;ViewController.m:person.eat4().sleep4();person.sleep4().eat4(); 5.实现函数式 + 链式(带参)12345678910111213141516171819202122232425262728Person.h:- (Person * (^)(NSString *foodName))eat5;- (Person * (^)(NSInteger hour))sleep5;Person.m:- (Person *(^)(NSString *))eat5&#123; Person * (^eat5Block)() = ^(NSString *foodName) &#123; NSLog(@&quot;吃: %@&quot;,foodName); return self; &#125;; return eat5Block;&#125;//上下两种写法一样- (Person *(^)(NSInteger))sleep5&#123; return ^(NSInteger hour) &#123; NSLog(@&quot;睡了%ld小时&quot;,(long)hour); return self; &#125;;&#125;ViewController.m:person.eat5(@&quot;蛋糕&quot;).sleep5(8);person.sleep5(8).eat5(@&quot;面包&quot;);]]></content>
      <categories>
        <category>iOS_Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>链式编程和函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>