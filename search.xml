<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML网页布局方式总结 |有码有真相|]]></title>
    <url>%2F2017%2F10%2F11%2FHTML%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93-%E6%9C%89%E7%A0%81%E6%9C%89%E7%9C%9F%E7%9B%B8%2F</url>
    <content type="text"><![CDATA[HTML三种布局方式总结1 普通流又称为常规流，浏览器默认的排版方式。普通流是元素在多数情况下呈现在WEB页面上的方式。所有HTML都在块框(block boxes，块级元素)或者行内框(inline boxes，行内元素)中。当浏览器开始渲染HTML文档，它从窗口的顶端开始，经过整个文档内容的过程中，分配元素需要的空间。除非文档的尺寸被 CSS 特别的限定，否则浏览器垂直扩展文档来容纳全部的内容。每个新的块级元素渲染为新行。行内元素（行内元素/行内块级）则按照顺序被水平渲染直到当前行遇到了边界，然后换到下一行垂直渲染。1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; h1, h4, p, span, strong, em, a &#123; border: 2px solid red; &#125; .setting &#123; width: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;块级元素&lt;/h1&gt;&lt;h4&gt;块级元素&lt;/h4&gt;&lt;p&gt;块级元素从上到下排列&lt;/p&gt;&lt;p class=&quot;setting&quot;&gt;块级元素从上到下排列,但是我的宽度被设置了&lt;/p&gt;&lt;a href=&quot;#&quot;&gt;行内元素1&lt;/a&gt;&lt;span&gt;行内元素2&lt;/span&gt;&lt;strong&gt;行内元素3&lt;/strong&gt;&lt;em&gt;行内元素从左到右&lt;/em&gt;&lt;/body&gt; 2 定位流 1&gt; absolute，绝对定位：绝对定位的元素位置是相对于距离它最近的那个已定位（定位流）的祖先(相对/绝对/固定)元素决定的。 如果元素没有已定位的祖先元素， 那么它的位置相对于初始包含块（body）进行定位。12345678910111213141516171819202122232425262728293031&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .div1 &#123; /*控制div2的父视图是否定位*/ /*position: absolute;*/ background-color: red; width: 200px; height: 200px; margin-left: 200px; &#125; .div2 &#123; position: absolute; background-color: yellow; width: 100px; height: 100px; left: 10px; top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt; &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 绝对定位的元素是脱离标准流的。不会占用标准流中的空间。 绝对定位的元素不区分块级元素/行内元素/行内块级元素。 如果一个绝对定位的元素是以body作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点。定位的元素会随着页面滚动而滚动。 当一个盒子绝对定位之后不能使用margin: 0 auto;让盒子自身居中，可以使用left: 50%; margin-left:-元素宽度一半px设置居中; 2&gt; fixed，固定定位：固定定位可以理解为是绝对定位的一种。固定定位的元素位置是相对于浏览器窗口决定的。这使得能够创建总是出现在窗口固定位置的元素。12345678910111213141516171819202122232425262728293031323334353637383940&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .div1 &#123; position: fixed; background: red; width: 100px; height: 100px; left: 20px; top: 20px; &#125; .div2 &#123; position: fixed; background: blue; width: 100px; height: 100px; left: 20; bottom: 20px; &#125; .div3 &#123; position: fixed; background: yellow; width: 100px; height: 100px; right: 20px; bottom: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt; &lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 固定定位的元素是脱离标准流的, 不会占用标准流中的空间。即可以理解为从标准流中删除。 固定定位的元素是不区分块级元素/行内元素/行内块级元素。 E6和更低版本不支持固定定位，可以使用javascript解决。 3&gt; inherit，继承：继承父元素position属性的值。123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .div2 &#123; position: fixed; background: blue; width: 100px; height: 100px; left: 20px; bottom: 20px; &#125; .div3 &#123; position: inherit; background: yellow; width: 100px; height: 100px; right: 20px; bottom: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div2&quot;&gt; &lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;&lt;/div&gt; 4&gt; relative，相对定位：相对定位就是相对于自己以前在普通流中的位置来移动。即相对于其正常位置进行定位。1234567891011121314151617181920212223242526272829303132333435&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 200px; height: 100px; &#125; .div1 &#123; background-color: aquamarine; &#125; .div2 &#123; background-color: chocolate; position: relative; left: 20px; top: 20px; &#125; .div3 &#123; background-color: coral; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;div3&quot;&gt;&lt;/div&gt;&lt;/body&gt; 使用相对定位时，无论该元素是否移动，元素仍然占据原先的空间，因此移动元素会导致它覆盖其他框。 在相对定位中同一个方向上的定位属性只能使用一个。 相对定位是不脱离标准流的, 所以在相对定位中区分块级元素/行内元素/行内块级元素。且因为相对定位的元素会占用标准流中的位置, 所以当给相对定位的元素设置margin/padding等属性的时会影响到标准流的布局。 5&gt; static，静态定位：默认值，没有定位，元素出现在正常的流中，即上面的普通流，忽略 top, bottom, left, right 或者 z-index 声明。3 浮动流浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐。先浮动的元素会显示在前面, 后浮动的元素会显示在后面。 浮动流中没有居中对齐, 没有center这个取值。在浮动流中是不可以使用margin: 0 auto。 在浮动流中是不区分块级元素/行内元素/行内块级元素的。无论是块级元素/行内元素/行内块级元素都可以水平排版。都可以设置宽高。 当元素被设置为浮动后，那么他会脱离标准流（脱标），不会占用标准流中的空间。如果此时后面的元素没有浮动，那么此时这个元素会盖住后面的元素。 1&gt; inherit，继承：继承父元素float属性的值。2&gt; left，左浮动：元素向左浮动。先浮动的在左边，后浮动的在右边。1234567891011121314151617181920212223242526&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding:0; &#125; div &#123; width: 100px; height: 100px; background-color: rebeccapurple; float: left; margin-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt; &lt;div&gt;div4&lt;/div&gt; &lt;div&gt;div5&lt;/div&gt;&lt;/ul&gt;&lt;/body&gt; 3&gt; none，不浮动：默认值。4&gt; right，右浮动：元素向右浮动。先浮动的在右边，后浮动的在左边。123456789101112131415161718192021222324252627&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding:0; &#125; div &#123; width: 100px; height: 100px; background-color: rebeccapurple; float: right; margin-left: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;div&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt; &lt;div&gt;div4&lt;/div&gt; &lt;div&gt;div5&lt;/div&gt;&lt;/ul&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>HTML布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache、Tomcat、静态网页、动态网页]]></title>
    <url>%2F2017%2F09%2F18%2FApache%E3%80%81Tomcat%E3%80%81%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E3%80%81%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[Apache &amp; TomcatApache1、C语言实现的，专门用来提供HTTP服务。2、特性：简单、速度快、性能稳定、可配置（代理），主要用于解析静态文本，并发性能高，侧重于HTTP服务；3、支持静态页（HTML），不支持动态请求如：CGI、Servlet/JSP、PHP、ASP等；4、具有很强的可扩展性，可以通过插件支持PHP，还可以单向Apache连接Tomcat实现连通。Apache是世界使用排名第一的Web服务器。Tomcat1、是Java开发的一个符合JavaEE的Servlet规范的JSP服务器（Servlet容器），是 Apache 的扩展。免费的Java应用服务器 2、主要用于解析JSP/Servlet，侧重于Servlet引擎；3、支持静态页，但效率没有Apache高；支持Servlet、JSP请求；4、Tomcat本身也内置了一个HTTP服务器用于支持静态内容，可以通过Tomcat的配置管理工具实现与Apache整合。Apache + Tomcat：两者整合使用的优点：如果请求是静态网页则由Apache处理，并将结果返回；如果是动态请求，Apache会将解析工作转发给Tomcat处理，Tomcat处理后将结果通过Apache返回。这样可以达到分工合作，实现负载远衡，提高系统的性能。Apache是一个web服务器环境程序，可以作为web服务器使用。不过只支持静态网页，如(asp,php,cgi,jsp)等动态网页的就显得无能为力。如果要在Apache环境下运行jsp的话就需要一个解释器来执行jsp网页，而这个jsp解释器就是Tomcat, 还需要jdk，jsp需要连接数据库的话，就要jdk来提供连接数据库的驱程，所以要运行jsp的动态web服务器平台就需要Apache+tomcat+jdk。 静态网页 &amp; 动态网页静态网页：1、在静态Web程序中，客户端使用Web浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给Web服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过Web服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。2、为了让静态页面显示更加好看，使用javascript／VBScript／ajax（AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。）但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。3、静态页面无法连接数据库；4、由于现在的web页面中，大量使用JS，导致浏览器打开页面，就会占用大量的内存，服务端的压力是减轻了，但压力转移到了客户端。5、运行在客户端的程序、网页、插件、组件，属于静态网页，例如：html，javascript等等，他们可以脱离服务器运行于浏览器客户端。6：静态网页的内容相对稳定，URL地址相对于动态网页的更加容易被搜索引擎识别,所以网站进行SEO优化的时候一般都是建议采用静态网页。7：静态网页无需数据库的支持，所以访问速度上较之动态网页比较快，不过随着浏览器以及宽带速度提升，这种差别会越来越小。动态网页：1、动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server来处理。2、如果客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。 3、常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。如果客户端请求的是动态资源（.jsp、.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。4、再进一步深入分析动态web的访问过程：浏览器访问web时，看似是直接访问的jsp页面，其实是，最先到达的地方是服务器，服务器创建好req和resp对象后再给jsp页面使用。JSP的前身是servlet；在jsp中完成设置字符集和取得表单参数后再调用servlet，完成业务处理。然后返回到jsp，jsp就会生成相应的html页面。该页面会返回到服务器，再由服务器，通过response对象返回给客户端。 5、运行在服务器端的程序、网页、组件，属于动态网页，例如：JSP,ASP,PHP等，它们会随不同客户、不同时间，返回不同的网页。6、为什么需要web服务器？(web server)1）不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。2）WEB服务器就是这样一个程序，它用于完成底层网络通迅，处理http协议。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。静态网页和动态网页区别的简单描述1、静态页面就是设计者把页面上所有东西都设定好、做死了，然后放上去，不管是谁在任何时候看到的页面内容都是一样的，一成不变（除非手动修改页面内容）。运行于客户端的程序、网页、插件、组件，属于静态网页，例如html页、Flash、JavaScript、VBScript等等，它们是永远不变的。静态html页面文件，可以直接用本地的浏览器打开。比如：file:///Users/Phil/Documents/DevOps/HBuilderProjects/testJSP/index.html。静态页面放到什么地方都能运行的。动态页面则不行。2、程序是否在服务器端运行，这个是判断网页属不属于动态网页的重要标志。动态页面是需要服务器解释的。动态页面的内容一般都是依靠服务器端的程序来生成的，不同人、不同时候访问页面，显示的内容都可能不同。网页设计者在写好服务器端的页面程序后，不需要手工控制，页面内容会按照页面程序的安排自动更改变换。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如ASP、PHP、JSP、ASP.net、CGI等。3、动态网页相比静态网页的交互性更高，可以实现更多的功能，如用户注册、登录等一系列用户需要与网站发生互动的功能基本都需要由动态网页来满足。动态网页，与网页上的各种动画、滚动字幕等视觉上的“动态效果”没有直接关系，动态网页也可以是纯文字内容的，也可以是包含各种动画的内容，这些只是网页具体内容的表现形式，无论网页是否具有动态效果，采用动态网站技术生成的网页都称为动态网页4、动态网页不是一个独立存在服务器上的网页，当用户发送请求时，服务器可能还要拼凑其他元素才会返回一个完整的网页，而静态网页一旦上传到服务器上，就是实实在在保存在服务器上的网页文件。5、html是w3c规范的一种网页书写格式，是一种统一协议语言，静态网页。我们上网看的网页都是大部分都是基于html语言的。jsp是一种基于动态语言，jsp可以实现html的所有任务，6、HTML（Hypertext Markup Language）文本标记语言，它是静态页面，和JavaScript一样解释性语言，为什么说是解释性语言？因为，只要你有一个浏览器那么它就可以正常显示出来，而不需要指定的编译工具，只需在TXT文档中写上HTML标记就可以正常显示。JSP（Java Server Page）是Java服务端的页面，所以它是动态的，它是需要经过JDK编译后把内容发给客户端去显示，我们都知道，Java文件编译后会产生一个class文件，最终执行的就是这个class文件，7、html和jsp的表头不一样，这个是JSP的头“ &lt;%@ page language=”java” import=”java.util.*” pageEncoding=”gbk”%&gt;”在表头中有编码格式和倒入包等。也是很好区分的，在jsp中用&lt;%%&gt;就可以写Java代码了，而html没有&lt;%%&gt;。8、不认识jsp或者asp什么什么的，但是有时候界面需要逻辑控制，所以我们就用相应的技术来实现，这样比较方便。而jsp在后台通过服务器解析为相应的html，然后在供浏览器识别显示。例如1234567&lt;%if(flag == a)&#123;&lt;label&gt;a&lt;label&gt;&#125;else &#123;&lt;label&gt;b&lt;label&gt;&#125;%&gt; 服务器在读取到这段代码后，根据相应的业务逻辑，编译成相应的servlet，再由servlet输出到页面（输出的就是html）。9、总之而言，静态网页适合更新较少的网站，一般适用于展示型的网站，而动态网页则更新较多，一般用于用户互动较多的网站。静态网页和动态网页实验测试1、在HBuilder中创建jsp页面，其内置的web静态服务器不能解析jsp表头，只能作为文本显示输出，但是可以解析其中的html部分。浏览器不能直接打开jsp文件。jsp页面如果想正确的显示，需要web容器进行解析。 2、在IntelliJ中创建web application，需要启动tomcat，才能运行jsp，可以顺利解析jsp的表头。]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>Web服务</tag>
        <tag>Apache</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现快递查询功能（界面传值、JSON数据请求和解析、radio-group的使用...）]]></title>
    <url>%2F2017%2F09%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%92%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%EF%BC%88%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC%E3%80%81JSON%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%92%8C%E8%A7%A3%E6%9E%90%E3%80%81radio-group%E7%9A%84%E4%BD%BF%E7%94%A8-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[运行效果： 请求数据之前需要首先在小程序平台设置服务器域名 第一个界面的实现：界面传值、radio-group的使用first.wxml123456789101112131415161718&lt;!--first.wxml--&gt;&lt;view class=&quot;first_view&quot;&gt; &lt;text&gt;请选择快递公司：&lt;/text&gt; &lt;!-- 单项选择器控件 --&gt; &lt;radio-group class=&quot;radio_group&quot; bindchange=&quot;listenRadioGroup&quot;&gt; &lt;!--用view包含每个实现垂直排列 --&gt; &lt;view wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:key=&quot;key&quot;&gt; &lt;radio value=&apos;&#123;&#123;item.value&#125;&#125;&apos; checked=&apos;&#123;&#123;false&#125;&#125;&apos;&gt;&#123;&#123;item.name&#125;&#125;&lt;/radio&gt; &lt;/view&gt; &lt;/radio-group&gt; &lt;!-- 输入框控件 --&gt; &lt;input class=&quot;input_view&quot; type=&quot;number&quot; bindinput=&quot;getInputText&quot; cursor-spacing=&apos;10&apos; placeholder=&quot;请输入快递单号&quot; auto-focus/&gt; &lt;button bindtap=&quot;jump&quot;&gt;查询快递&lt;/button&gt;&lt;/view&gt; first.wxss123456789101112/* first.wxss */.first_view &#123; display: flex; flex-direction: column;&#125;.input_view &#123; margin-top: 30rpx; margin-bottom: 30rpx; background-color: rgb(250, 250, 250);&#125; first.js123456789101112131415161718192021222324252627282930313233343536373839404142// first.js//创建两个变量，保存快递单号和快递类型var kd_typevar kd_numPage(&#123; /** * 页面的初始数据 */ data: &#123; items: [ &#123; name: &quot;申通&quot;, value: &quot;shentong&quot; &#125;, &#123; name: &quot;EMS&quot;, value: &quot;ems&quot; &#125;, &#123; name: &quot;顺丰&quot;, value: &quot;shunfeng&quot; &#125;, &#123; name: &quot;圆通&quot;, value: &quot;yuantong&quot; &#125;, &#123; name: &quot;韵达&quot;, value: &quot;yunda&quot; &#125;, &#123; name: &quot;天天&quot;, value: &quot;tiantian&quot; &#125;, &#123; name: &quot;汇通&quot;, value: &quot;huitongkuaidi&quot; &#125;, &#123; name: &quot;全峰&quot;, value: &quot;quanfengkuaidi&quot; &#125;, &#123; name: &quot;德邦&quot;, value: &quot;debangkuaidi&quot; &#125;, &#123; name: &quot;宅急送&quot;, value: &quot;zhaijisong&quot; &#125;, ] &#125;, // 监听单项选择器radio_group的选中情况 listenRadioGroup: function (value) &#123; console.log(value) kd_type = value.detail.value &#125;, // 获取文本框input的输入内容 getInputText: function (inputText) &#123; console.log(inputText.detail.value) kd_num = inputText.detail.value &#125;, // “查询快递”按钮点击事件 jump: function () &#123; wx.navigateTo(&#123; // 参数拼接传到下一个界面 url: &apos;../second/second?postid=&apos; + kd_num + &apos;&amp;type=&apos; + kd_type, &#125;) &#125;&#125;) 第二个界面的实现：JSON数据请求和解析JSON数据格式如下: second.wxml123456789101112131415&lt;!--second.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;text class=&quot;title&quot;&gt; 快递单号：&#123;&#123;result.nu&#125;&#125; 快递公司：&#123;&#123;result.com&#125;&#125; &lt;/text&gt; &lt;block wx:for=&quot;&#123;&#123;result.data&#125;&#125;&quot; wx:key=&quot;key&quot;&gt; &lt;text&gt; &#123;&#123;item.time&#125;&#125; &#123;&#123;item.context&#125;&#125; &lt;/text&gt; &lt;/block&gt;&lt;/view&gt; second.wxss123456789/**second.wxss**/.title &#123; font-size: 40rpx;&#125;text &#123; font-size: 30rpx;&#125; second.js1234567891011121314151617181920212223242526272829303132333435363738394041//second.js//获取应用实例var app = getApp()Page(&#123; onLoad: function (option) &#123; console.log(&apos;界面跳转成功&apos;) var that = this // 数据请求 wx.request(&#123; url: &apos;http://www.kuaidi100.com/query?&apos;, // 参数请求所需的参数 data: &#123; type: option.type, postid: option.postid &#125;, // 数据请求方式 method: &apos;GET&apos;, // 请求成功 success: function (res) &#123; console.log(&quot;返回的数据为&quot; + res) // 设置数据 that.setData(&#123; result: res.data &#125;) &#125;, // 请求失败 fail: function () &#123; console.log(&apos;fail&apos;); &#125;, // 请求完成 complete: function () &#123; console.log(&apos;complete&apos;); &#125; &#125;) //调用应用实例的方法获取全局数据 app.getUserInfo(function (userInfo) &#123; //更新数据 that.setData(&#123; userInfo: userInfo &#125;) &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>WeChat</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>JSON解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Windows安装配置Apache服务 / 基于Windows安装配置IIS服务 / Apache与IIS对比]]></title>
    <url>%2F2017%2F08%2F03%2F%E5%9F%BA%E4%BA%8EWindows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEApache%E6%9C%8D%E5%8A%A1-%E5%9F%BA%E4%BA%8EWindows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEIIS%E6%9C%8D%E5%8A%A1-Apache%E4%B8%8EIIS%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[当前环境:Mac + PD(64位win10) 基于Windows安装配置Apache服务一:在Apache官网下载Apache1&gt;点击download! 2&gt;选择当前最新版本2.4.27 3&gt;点击 File for Microsoft Windows 4&gt;这里面还有一些别的开发工具, 这里选择Apache Lounge 5&gt;根据实际电脑操作系统下载压缩包 6&gt;把压缩包解压得到一个文件夹Apache24, 当前把文件夹放到了C盘二:安装Apache服务1&gt;命令提示符进到Apache24文件夹下的bin文件夹, 执行命令启动Apache服务1httpd -k install 附:重启服务命令 / 卸载命令 / 停止服务命令 / 启动命令1234httpd -k restart //重启服务httpd -k uninstall //卸载服务httpd -k stop //停止服务httpd -k start //停止服务 1.1&gt;若出现Installing the &#39;Apache24&#39; service(OS 5)拒绝访问. :AH00369: Failed to open the WinNT service manager.&quot; 1.1&gt;解决办法:以管理员身份运行cmd.exe 1.2&gt;若出现Could not reliably determine the server&#39;s fully qualifi. 1.2解决办法: 用记事本打开Apach24 -&gt; conf目录下的httpd,找到ServerName www.example.com:80,去掉前面的#, 然后重启服务1.3&gt;若出现Errors reported here must be corrected before the service can be started1.3&gt;出现这句话不需要解决,这句话下面有error需要解决,这句话的意思是说如果这个位置出现错误的话需要在服务启动之前修复,只是一个提示而已.2&gt;在管理员运行的cmd.exe中执行Apache服务启动命令(进到bin目录) 3&gt;启动Apache服务1httpd -k start 3.1也可以双击Apache24 -&gt; bin 目录下的ApacheMonitor.exe, 然后点击start 三:验证Apache服务是否安装成功在浏览器地址栏键入127.0.0.1, 出现 基于Windows安装配置IIS服务一:打开控制面板 -&gt; 程序和功能 -&gt; 启用或关闭Windows功能 # 二:勾选Internet Information Services(IIS) -&gt; 点击确定 加载完成后关闭窗口 此时在浏览器键入127.0.0.1,显示如下: 上面的操作会在C盘生成一个inetpub的文件夹, 我们把需要展示网站代码文件放到该文件夹下的wwwroot, 便可以使用IP访问网站,比如:127.0.0.1/index.html或者127.0.0.1/about/profile.html, 再就是域名解析该IP实现域名访问 三:关闭IIS服务按Win 和R，打开运行窗口 -&gt; 输入services.msc确定打开服务窗口 -&gt; 停止”World Wide Web 发布服务”。 Apache和IIS对比IIS IIS在实际使用中经常出现500错误，而且有的时候还会出现莫名其妙的假死现象。用户需要不定期的重新启动IIS服务才能保证网站的正常。 IIS只能在微软公司的windows操作系统下使用，无法移植到其他类型的操作系统中。 IIS是windows系统的一部分，所以他的源代码是没有开放的。 IIS操作起来比较简单，很容易就可能让IIS对外发布网站。开发人员很容易出现错误配置和误操作问题。不过总体说来IIS还是非常容易学的，但学好他恐怕是件非常困难的事。 Apache Apache在配置上比IIS要复杂，不过一经设置完毕就可以长期的工作了。大型网站都使用Apache作为自己的WWW服务提供工具。Apache的所有配置都保存在配置文件中，使用时完全按照配置文件中记录的信息执行。一般不会发生莫名其妙的假死情况。 Apache是个多面手，他不仅仅应用于windows，对于unix, linux以及freebsd等多种操作系统来说他都可以胜任工作。而且不同操作系统的配置步骤基本类似，可移植性非常高。 Apache最早他是为了类unix系统服务的，所以完全对外开放源代码。任何人都可以分析他的代码，发现其中的漏洞，并发布补丁来弥补该漏洞。正因为Apache的这种开放性，也使其安全性大大提高。 Apache的使用比IIS要难，需要有一定计算机及网络基础的人才可以使用。他的配置也不是图形化的，需要我们通过编辑配置文件来实现。但是单从Apache的设置上讲，只要我们严格按照帮助文件进行参数设置的话还是没有什么难度的。]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>Web服务</tag>
        <tag>Apache</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-基础标签总结]]></title>
    <url>%2F2017%2F07%2F03%2FHTML-%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[👉使用ul,添加无序列表(unordered list)使用ul-li标签来完成。ul-li是没有前后顺序的信息列表。li是英文list item的缩写1234567&lt;body&gt;&lt;ul&gt; &lt;li&gt;完美生活&lt;/li&gt; &lt;li&gt;蓝莲花&lt;/li&gt; &lt;li&gt;一起摇摆&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 显示效果： 在webstorm中快速编写一个ul的格式 ul&gt;li(然后按下Tab键)含义: 生成一对ul标签, 然后在这对ul标签中再生成一对li标签 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; ul&gt;li*3(然后按下Tab键)含义: 生成一对ul标签, 然后在这对ul标签中再生成3对li标签 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 👉使用ol,添加有序列表(ordered list)&lt;ol&gt;在网页中显示的默认样式一般为：每项&lt;li&gt;前都自带一个序号，序号默认从1开始1234567&lt;body&gt;&lt;ol&gt; &lt;li&gt;完美生活&lt;/li&gt; &lt;li&gt;蓝莲花&lt;/li&gt; &lt;li&gt;一起摇摆&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 显示效果： 👉div排版在网页制作过程过中，可以把一些独立的逻辑部分划分出来，放在一个&lt;div&gt;标签中，这个&lt;div&gt;标签的作用就相当于一个容器。1234&lt;div style=&quot;color: aqua; background-color: chocolate&quot;&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt; &lt;p&gt;这是一个段落&lt;/p&gt;&lt;/div&gt; 显示效果： 👉给div命名，使逻辑更加清晰为了使逻辑更加清晰，我们可以为这一个独立的逻辑部分设置一个名称，用id属性来为&lt;div&gt;提供唯一的名称，这个就像我们每个人都有一个身份证号。123456&lt;div id=&quot;header&quot; style=&quot;color: aqua; background-color: chocolate&quot;&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt;&lt;/div&gt;&lt;div id=&quot;paragraph&quot; style=&quot;height: 60px; background-color: firebrick&quot;&gt; &lt;p&gt;这是段落&lt;/p&gt;&lt;/div&gt; 显示效果： 👉table标签，制作表格创建表格的四个元素table、tbody、tr、th、td &lt;table&gt;…&lt;/table&gt;：整个表格以&lt;table&gt;标记开始、&lt;/table&gt;标记结束。 &lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。） &lt;tr&gt;…&lt;/tr&gt;：表格的一行，所以有几对tr 表格就有几行。 &lt;td&gt;…&lt;/td&gt;：表格的一个单元格，一行中包含几对&lt;td&gt;…&lt;/td&gt;，说明一行中就有几列。 &lt;th&gt;…&lt;/th&gt;：表格的头部的一个单元格，表格表头。 表格中列的个数，取决于一行中数据单元格的个数。 table表格在没有添加css样式之前，在浏览器中显示是没有表格线的 表头，也就是th标签中的文本默认为粗体并且居中显示12345678910111213141516171819&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;2班&lt;/td&gt; &lt;td&gt;12岁&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小李&lt;/td&gt; &lt;td&gt;1班&lt;/td&gt; &lt;td&gt;11岁&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 显示效果： 👉使用css样式为表格加入边框1234567891011121314151617181920212223&lt;style&gt; table tr td,th&#123;border: 1px solid #000&#125;&lt;/style&gt;&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;2班&lt;/td&gt; &lt;td&gt;12岁&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小李&lt;/td&gt; &lt;td&gt;1班&lt;/td&gt; &lt;td&gt;11岁&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; ###显示效果： 👉caption标签为表格添加标题和摘要###摘要：摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。语法：&lt;table summary=&quot;表格简介文本&quot;&gt; 标题：用以描述表格内容，标题的显示位置：表格上方。语法：123456789&lt;table&gt; &lt;caption&gt;标题文本&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;…&lt;/td&gt; &lt;td&gt;…&lt;/td&gt; … &lt;/tr&gt;…&lt;/table&gt; 1234567891011121314151617181920&lt;table summary=&quot;班级信息表&quot;&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;2班&lt;/td&gt; &lt;td&gt;12岁&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小李&lt;/td&gt; &lt;td&gt;1班&lt;/td&gt; &lt;td&gt;11岁&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 显示效果： 👉定义列表给一数据添加列表语义，先通过dt标签定义列表中的所有标题, 然后再通过dd标签给每个标题添加描述信息·，语法信息：1234567891011&lt;body&gt;&lt;dl&gt; &lt;dt&gt;手机&lt;/dt&gt; &lt;dd&gt;iPhone&lt;/dd&gt; &lt;dd&gt;华为, OPPO, 三星&lt;/dd&gt; &lt;dt&gt;电脑&lt;/dt&gt; &lt;dd&gt;MAC, WiN&lt;/dd&gt;&lt;/dl&gt;&lt;/body&gt;dt是definition title的缩写, 用来定义列表中的标题dd是definition description的缩写, 用来定义标题对应的描述 显示效果： 👉&lt;a&gt;标签，链接到另一个界面使用&lt;a&gt;标签可实现超链接，语法：1&lt;a href=&quot;目标网址&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt; title属性的作用，鼠标滑过链接文字时会显示这个属性的文本内容。这个属性在实际网页开发中作用很大，主要方便搜索引擎了解链接地址的内容（语义化更友好）默认只要为文本加入a标签后，文字的颜色就会自动变为蓝色（被点击过的文本颜色为紫色） a标签不仅可以让文字可以点击, 图片也能够被点击 一个a标签必须有一个href属性 当a标签的href属性指定的是一个URL地址, 那么必须在地址前面加上http://或https:// a标签的href属性除了可以指定一个网络地址以外, 还可以指定一个本地地址 1234&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;百度&quot;&gt;点击跳转百度&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/feng2qing?viewmode=list&quot; title=&quot;Stevin三天三夜的专栏&quot;&gt;Stevin三天三夜&lt;/a&gt;&lt;/ul&gt; 显示效果：点击在当前页进行跳转 👉&lt;a&gt;标签，在新建浏览器中打开链接&lt;a&gt;标签在默认情况下，链接的网页是在当前浏览器窗口中打开，有时我们需要在新的浏览器窗口中打开。1&lt;a href=&quot;目标网址&quot; target=&quot;_blank&quot;&gt;click here!&lt;/a&gt; 1234&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot; title=&quot;百度&quot;&gt;点击跳转百度&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/feng2qing?viewmode=list&quot; title=&quot;Stevin三天三夜的专栏&quot;&gt;Stevin三天三夜&lt;/a&gt;&lt;/ul&gt; 显示效果：点击百度在新界面打开 👉使用mailto在网页中链接Email地址 注意：如果mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的参数每一个都以“&amp;”分隔。123&lt;ul&gt; &lt;a href=&quot;mailto:shaofeng7998@foxmail.com?cc=1170197998@qq.com&amp;bcc=1170197998@qq.com&amp;subject=主题&amp;body=邮件&quot;&gt;点击发送&lt;/a&gt;&lt;/ul&gt; 显示效果：点击会唤起本地邮箱软件 👉&lt;img&gt;标签，为网页插入图片语法：&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt; src：标识图像的位置；可以是本地路径或者网络路径。 alt：alternate的缩写，指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本； title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)； 图像可以是GIF，PNG，JPEG格式的图像文件。 如果手动指定了图片的高度和宽度，那么可能会导致图片变形，此时可以这样做：高度和宽度只指定一个，指定宽度时，高度会自动算出，不会变形。反之指定高度的时候宽度也会自动算出。都没有指定的时候，会按照默认的宽高来显示 1&lt;img src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=235732466,99834328&amp;fm=23&amp;gp=0.jpg&quot; alt=&quot;Imgae&quot; title=&quot;GIF图&quot;&gt; 显示效果： 👉base标签base标签就是用来统一的当前网页中所有的超链接(a标签)如何打开，必须写在head标签的开始标签和结束标签之间 如果既在base中指定了target又在a标签中指定了target,那么浏览器会按照a标签中指定的来执行 12&lt;base target=&quot;_blank&quot;&gt; //在新标签中打开&lt;base target=&quot;_self&quot;&gt; //在当前页中打开 123456789&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;11-base标签&lt;/title&gt; &lt;base target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&gt;百度&lt;/a&gt;&lt;a href=&quot;http://blog.csdn.net/feng2qing/article/list/2&quot;&gt;Blog&lt;/a&gt;&lt;/body&gt; 显示效果： 百度在当前页面打开，Blog在新标签打开👉假链接假链接点击之后不会发生界面的跳转，有两种格式#，javascript，前者点击会回到网页顶部，后者不会发生变化 12&lt;a href=&quot;#&quot;&gt;点我调到顶部&lt;/a&gt;&lt;a href=&quot;javascript:&quot;&gt;点我不发生变化&lt;/a&gt; 显示效果： 👉锚点通过a标签跳转到网页指定位置 给目标位置设置id属性 把目标位置的id值告诉a标签 a标签进行位置跳转是没有动画的 123&lt;!--点击a标签的文字会跳转到下面p标签的位置--&gt;&lt;a href=&quot;#center&quot;&gt;跳转到中部&lt;/a&gt; &lt;p id=&quot;center&quot;&gt;我是中部&lt;/p&gt; a标签除了可以跳转到当前界面的指定位置以外, 还可以跳转到其他界面的指定位置 123&lt;!--点击a标签的文字会跳转到DEMO界面id = bottom的位置，并且是在新标签中打开--&gt;&lt;a href=&quot;DEMO2.html#bottom&quot; target=&quot;_blank&quot;&gt;跳转到DEMO2界面&lt;/a&gt;&lt;h2 id=&quot;bottom&quot;&gt;DEMO2界面&lt;/h2&gt;]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS && Xcode8安装RVM,安装Ruby,安装/卸载Cococapods全程详解]]></title>
    <url>%2F2017%2F06%2F21%2FmacOS-Xcode8%E5%AE%89%E8%A3%85RVM-%E5%AE%89%E8%A3%85Ruby-%E5%AE%89%E8%A3%85-%E5%8D%B8%E8%BD%BDCococapods%E5%85%A8%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一.安装RVM1.指令:$ curl -L https://get.rvm.io | bash -s stable网络不好会导致如下界面: 安装成功显示: 2.载入RVM环境指令:$ source ~/.rvm/scripts/rvm回车后不会有任何反应3.检查RVM是否安装成功(查看RVM版本):$ rvm -v回车后显示: 二.用RVM安装Ruby环境1.列出已知的ruby版本:$ rvm list known 2.查看当前ruby版本:$ ruby -v 3.安装指定ruby版本,安装的过程中会有回车确认操作和输入电脑密码操作:$ rvm install ruby-2.3[.0]上传完成显示如下: 4.将指定版本的 Ruby 设置为系统默认版本:$ rvm 2.3[.0] –default5.查看当前Ruby版本:$ ruby -v 6.Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题,但是唐巧博客中写道:淘宝的镜像源 ruby.taobao.org 停止更新了，所以使用 CocoaPods 的同学，提示更新到 ruby china 的源。7.移除rubygems.org:$ gem source -r https://rubygems.org/8.更新为ruby china:$ gem source -a https://gems.ruby-china.org/9.查看当前使用的镜像源:$ gem sources -l替换成功 三.安装Cocoapods1.安装命令:$ sudo gem install cocoapods打印一堆log后显示如下: 2.将podspec索引文件更新到本地:$ pod setup3.查看当前Cocoapods版本:$ pod –version 四.在项目中用Cocoapods管理三方框架 1.验证某个框架是否知否Pods,查看其版本信息:$ pod search MJRefresh 如果出错提示下面的信息:1234567Setting up CocoaPods master repoSetup completedCreating search index for spec repo &apos;master&apos;.. Done![!] Unable to find a pod with name, author, summary, or description matching `MJRefresh`[!] Skipping `0` because the podspec contains errors.[!] Skipping `1` because the podspec contains errors.[!] Skipping `2` because the podspec contains errors. 删除cocoapods的索引，然后重新search即可:$ rm ~/Library/Caches/CocoaPods/search_index.json2.进入到项目工程文件夹:$ cd /Users/主机名/Desktop/Test3. 创建Podfile文件:$ touch Podfile 4.进入vim编辑Podfile文件:$ vim Podfile,按下”i”键键入以下内容1234platform :ios, &apos;8.0&apos;target &apos;Test&apos; do pod &apos;FMDB&apos;, &apos;~&gt;2.6.2&apos;end 按下esc,然后键入wq,保存并退出vim5.初始化到项目中:$ pod install 6.以后直接打开Test.xcworkspace即可打开工程 五.安装及以后的使用中可能用到的命令 1.初始化pod到项目中的时候如果: $ pod install 命令无法通过,可以尝试:$ pod install –verbose –no-repo-update2.更新三方框架时如果:$ pod update 命令无法通过,可以尝试:$ pod update –verbose –no-repo-update, 同样适用于更新指定框架:$ pod update FMDB –verbose –no-repo-update3.卸载一个已安装的ruby版本:$ rvm remove 2.2.24.查看已有源:$ gem source5.删除全局的缓存:$ sudo rm -fr ~/Library/Caches/CocoaPods/$ sudo rm -fr ~/.cocoapods/repos/master/6.清空Pods当前目录:$ sudo rm -fr Pods/在项目中彻底删除Cocoapods1.删除工程文件夹下的Podfile、Podfile.lock和Pods文件夹。2.删除xcworkspace文件。 3.打开xcodeproj文件，删除项目中的Pods文件夹及Pods.xcconfig引用和libpods.a：4.打开Build Phases选项，删除Check Pods Manifest.lock和CopyPods Resources，以及Embeded Pods Frameworks 删除后编译可能会有Missing file 的警告,这时在终端进入到警告所在的目录: cd 警告所在目录然后删除该文件:svn delete文件名,如果使用的是git,使用git delete 文件名]]></content>
      <categories>
        <category>Cocoapods</category>
      </categories>
      <tags>
        <tag>RVM</tag>
        <tag>Ruby</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple企业开发者账号打包ipa]]></title>
    <url>%2F2017%2F06%2F21%2FApple%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%89%93%E5%8C%85ipa%2F</url>
    <content type="text"><![CDATA[一:肯定要有企业开发者账号,没有的先自行申请,如果你已经有一个有效的账号继续往下看二:在开发者账号中心创建Certificates 和 Profiles 1.创建Certificates 由于已经创建过该类证书，所以不能再次创建。点击continue后会要求上传证书请求文件,制作方法如下1231.打开dock的Launchpad，在其他中找到“钥匙串访问”，在左上方导航条中选择“钥匙串访问”目录下的“证书助理”，选择“从证书颁发机构请求证书”2.得到如下界面(填写邮件地址,选择存储到磁盘),点击继续3.把证书保存到存储桌面.点击存储 点击choosefile,选择刚刚放到桌面上的钥匙串文件(.certSigningRequest),然后点击Generate,最后点击download下载到本地,双击运行即可.2.创建Identifiers 写入name和bundle id,选择必要的app server 预览,确认后点击Register,下一页点击Done即可 3.创建Provisioning Profiles 用 Certificate.去创建发布版本 选择上一步的Identifier 选择第一步的Certificates 输入name 下载Profiles 双击运行上面两个文件三:在项目中配置Certificates 和 Profiles1.Xcode 中登录开发者账号Apple Id2.点击PROJECT –&gt; Build Setterings –&gt; 对应选择Profile和证书,账号 3.点击TARGETS –&gt; Build Setterings –&gt; 对应选择Profile和证书,账号 4.点击Project –&gt; Edit Scheme –&gt; 修改为Release 5.把运行设备改为真机或者Generic iOS Deveice6.点击Project –&gt; Archive –&gt; 右侧Export 7.选取当前开发号 –&gt; Chooese 8.选择Export one app –&gt;next,加载完成后生成在桌面的文件夹中,完事~遇到任何问题欢饮私信或评论]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Apple企业开发者账号</tag>
        <tag>证书， 打包上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift / Objective_C / Xcode实际开发中可能遇到的小功能小技巧总结]]></title>
    <url>%2F2017%2F06%2F21%2FSwift-Objective-C-Xcode%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一:Swift3.0为视图添加旋转动画,效果如下: 代码实现: 123456789//创建动画let anim = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)//设置相关属性anim.toValue = 2 * M_PIanim.repeatCount = MAXFLOATanim.duration = 15//完成之后不移除,testView被释放,动画随着一起删除anim.isRemovedOnCompletion = false testView(anim, forKey: nil) 二:解决项目中每次界面跳转隐藏TabBar的问题思路:在UINavigationController 中重写pushViewController 方法,不必每次跳转都调用hidesBottomBarWhenPushed1234567override func pushViewController(_ viewController: UIViewController, animated: Bool) &#123; //隐藏tabbar if childViewControllers.count &gt; 0 &#123; viewController.hidesBottomBarWhenPushed = true &#125; super.pushViewController(viewController, animated: animated)&#125; 三:Swift3.0中使用NSLayoutConstraint为控件添加约束12345678//设置通过代码添加Constraint,否则View还是会按照以往的autoresizingMask进行计算centerButton.translatesAutoresizingMaskIntoConstraints = false//依次添加X,Y, W,Hview.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .centerX, relatedBy: .equal, toItem: self.view, attribute: .centerX, multiplier: 1.0, constant: 0))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .centerY, relatedBy: .equal, toItem: self.view, attribute: .centerY, multiplier: 1.0, constant: -60))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 50))view.addConstraint(NSLayoutConstraint(item: centerButton, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: 50)) 方法解读:在view视图中,为参数1添加约束设置 参数1(一般为视图) 的 参数2(坐标或宽高) 属性 参数3(大于等于小鱼) 参数4(参照视图) 的 参数5(坐标或宽高) 属性 乘以 参数6 加上 参数7注意:单纯设置宽高的时候,参数4传入nil,参数5传入.notAnAttribute1view.addConstraint(NSLayoutConstraint(item: 参数1, attribute: 参数2, relatedBy: 参数3, toItem: 参数4, attribute: 参数5, multiplier: 参数6, constant: 参数7)) 四:Swift3.0通过十六进制值设置UIColor1234567891011extension UIColor &#123; class func colorWithHex(hexValue: UInt32) -&gt; UIColor &#123; let r = (hexValue &amp; 0xff0000) &gt;&gt; 16 let g = (hexValue &amp; 0x00ff00) &gt;&gt; 8 let b = hexValue &amp; 0x0000ff return UIColor(red: CGFloat(r) / 255.0, green: CGFloat(g) / 255.0, blue: CGFloat(b) / 255.0, alpha: 1.0) &#125;&#125;//示例调用:view.backGroundColor = UIColor.colorWithHex(hexValue: 0xff0000) 五:Swift3.0中&amp;error的写法12var error: NSError?context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &amp;error) 六:动态设置TableView的滑动范围12345- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //一般获取最后控件的最大Y坐标,labelExplain是最后一个cell下追加的控件 self.tableView.contentSize = CGSizeMake(0,CGRectGetMaxY(self.labelExplain.frame) + 10);&#125; 七:clipstobounds与maskstobounds的区别12345clipsToBounds(UIView)是指视图上的子视图,如果超出父视图的部分就截取掉masksToBounds(CALayer)却是指视图的图层上的子图层,如果超出父图层的部分就截取掉 八:查看真机沙盒文件夹,查看真机崩溃日志 九:常用的路径位置1234567891011121314模拟器的位置:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置:/Applications/Xcode.app/Contents/Developer/Documentation/DocSets插件保存路径:~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins自定义代码段的保存路径:~/Library/Developer/Xcode/UserData/CodeSnippets/ //如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。描述文件路径~/Library/MobileDevice/Provisioning Profiles 十:富文本和HTML字符串互相转化12345678910111213//富文本转html字符串- (NSString *)attriToStrWithAttributeString:(NSAttributedString *)attributeString&#123; NSDictionary *tempDic = @&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute:[NSNumber numberWithInt:NSUTF8StringEncoding]&#125;; NSData *htmlData = [attributeString dataFromRange:NSMakeRange(0, attributeString.length) documentAttributes:tempDic error:nil]; return [[NSString alloc] initWithData:htmlData encoding:NSUTF8StringEncoding];&#125;//html字符串转富文本- (NSAttributedString *)strToAttriWithString:(NSString *)htmlString&#123; return [[NSAttributedString alloc] initWithData:[htmlString dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType&#125; documentAttributes:nil error:nil];&#125; 十一:Swift项目中引入Objective_C三方框架后手动桥接的方法1&gt;手动创建一个.h的文件,比如:Demo-Bridge.h2&gt;在Build Setteings 中找到 Objective_C Bridging Header 添加路径$(SRCROOT)/Demo/Demo-Bridge.h3&gt;包含Objective_C头文件,例如:#import &quot;UIView+WebCache.h&quot;十二:UITableView多行选择修改系统默认选择样式在自定义的cell中重写layoutSubviews12345678910111213141516171819202122- (void)layoutSubviews&#123; [super layoutSubviews]; // 设置UITableViewCellEditControl样式 for (UIControl *control in self.subviews) &#123; if ([control isMemberOfClass:NSClassFromString(@&quot;UITableViewCellEditControl&quot;)]) &#123; for(UIView *view in control.subviews) &#123; if([view isKindOfClass: [UIImageView class]]) &#123; UIImageView *img = (UIImageView *)view; if(self.selected) &#123; //选择状态图片 img.image= [UIImage imageNamed:@&quot;image1&quot;]; &#125; else &#123; //未选中状态图片 img.image= [UIImage imageNamed:@&quot;image2&quot;]; &#125; &#125; &#125; &#125; &#125;&#125; 十三:Xcode项目中一键替换项目中所有类中指定文字或代码1&gt;快捷键command + shift + F唤醒全局搜索并进入输入状态2&gt;切换Find为Replace(这里也可以采用正则进行查找搜索Regular Expression) 3&gt;输入要搜索的内容和替换结果,然后点击Replace All即可 十四:NSUserDefaults判断应用程序是否是安装完首次次启动123456if (![[NSUserDefaults standardUserDefaults] valueForKey:@&quot;FirstStart&quot;]) &#123; [[NSUserDefaults standardUserDefaults] setValue:@&quot;firstStart&quot; forKey:@&quot;FirstStart&quot;]; //第一次启动,可以设置欢迎页或者设置默认语言&#125; else &#123; //非第一次启动&#125; 十五:Swift 设置在debug模式下打印日志,并且锁定代码位置(Objective_C打印设置)1234567891011// 可以把下列代码放在AppDelegate的@UIApplicationMain的上方func DebugLog&lt;T&gt;(messsage : T, file : String = #file, funcName : String = #function, lineNum : Int = #line) &#123; #if DEBUG let fileName = (file as NSString).lastPathComponent print(&quot;\(fileName):(\(lineNum))-\(messsage)&quot;) #endif&#125;//使用方法DebugLog(messsage: &quot;test&quot;)//输出类名 + 代码行数 + 输出信息ViewController.swift:(37)-test 十六:修改默认开发语言(Xcode默认开发语言是英语)1&gt;先添加英语之外的一种语言 2&gt;Show in Finder工程文件 –&gt; 显示包内容 –&gt; 用文本打开project.pbxproj –&gt; 搜索developmentRegion –&gt; 将值改为zh-Hans 3&gt;修改成功十七:使用runtime为分类添加属性我们知道系统的UITableView的section和row属性，就是定义在NSIndexPath的分类里的 示例方法:123456789101112131415161718//写一个UIView的分类命名:UIView+CategoryUIView+Category.h//增加的属性@property (nonatomic, strong) NSObject *propertyTest;UIView+Category.m//加入运行时头文件#import &lt;objc/runtime.h&gt;@implementation UIView (Category)//获取关联的对象- (NSObject *)propertyTest &#123; return objc_getAssociatedObject(self, @selector(propertyTest));&#125;//给对象添加关联对象- (void)setPropertyTest:(NSObject *)value &#123; objc_setAssociatedObject(self, @selector(propertyTest), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;此后,就可以正常访问了该属性了 十八:App迭代开发版本号的规则0&gt;首先我们的App第一版本首次上线, 比如以1.0.0为首次上线的版本号1&gt;上线后突然发现一个严重的Bug那我们就要修复更新版本, 此时我们的版本号为1.0.1, 所以说如果修复Bug或者优化功能, 我们只修改叠加第三位数字, 其他不变2&gt;如果有了新的需求, 在原来的基础上增加了一个新功能, 那么我们的版本号变为1.1.0, 需要清空第三位数字为0, 来叠加修改第二位数字3&gt;如果App需求功能大改, 更新量非常大, 那我们的版本号变为2.0.0, 需要叠加修改第一位数字, 清空其他数字为0十九:Swift中懒加载先说说OC中的懒加载,通常是写get方法,例如:12345678- (DataModel *)model&#123; if (!_model) &#123; _model = [[DataModel alloc] init]; _model.title = @&quot;标题&quot;; &#125; return _model;&#125; swift中有专门的懒加载修饰符lazy,实现如下:12345private lazy var model: DataModel = &#123; let model = DataModel() model.title = &quot;标题&quot; return model&#125;() 二十:Swift中shouldAutorotate的重写123456789override open var shouldAutorotate: Bool &#123; return false / true&#125;//或者open override var shouldAutorotate: Bool &#123; get &#123; return false / true &#125;&#125; 二十一:屏幕旋转的时候状态栏显示问题如果是在视图View中,重写layoutSubviews;如果是在ViewController中重写viewWillLayoutSubviews,Swift代码如下:12345678910//视图控制器中override func viewWillLayoutSubviews() &#123; super.viewWillLayoutSubviews() UIApplication.shared.isStatusBarHidden = false&#125;//视图中override func layoutSubviews() &#123; super.layoutSubviews() UIApplication.shared.isStatusBarHidden = false&#125; 二十二:区分==,isEqual,isEqualToString==: 比较的是内存地址isEqual: 是 NSObject 的方法,首先都会判断指针是否相等 ,相等直接返回YES,不相等再判断是否是同类对象或非空,空或非同类对象直接返回NO,而后依次判断对象对应的属性是否相等,若均相等,返回YESisEqualToString: 是NSString的方法,从继承关系角度来说是 isEqual的衍生方法,在都是字符串的前提下,判断字符串的内容是否相等,如果知道了两个对象都是字符串,isEqualToString比isEqual要快二十三:修改GitHub项目显示语言1234567891011121314打开Terminal 进入到仓库文件夹$:cd /Users/MacName/Desktop/Demo创建一个`.gitattributes`的文件$:touch .gitattributes打开文件$:open .gitattributes写入如下代码,比如设置语言为Swift*.h linguist-language=swift*.m linguist-language=swift重新push项目到GitHub, 完成修改 二十四:Terminal命令查看系统隐藏文件1234567显示隐藏文件:$:defaults write com.apple.finder AppleShowAllFiles -bool true关闭显示隐藏文件:defaults write com.apple.finder AppleShowAllFiles -bool false***执行命令后需要打开强制退出界面(快捷键option+command+esc),重启Finder 二十五:Masonry布局后获取Frame值需要立即更新子视图的布局后获取即可1[self layoutIfNeeded]; 二十六:Xcode同时打开两个Simulator模拟器(做通信APP方便调试)打开终端进到xcode路径下的Applications路径1$:cd /Applications/Xcode.app/Contents/Developer/Applications/ 打开模拟器1$:open -n Simulator.app/ 或者执行一个脚本也可以,创建文件xim.sh,键入以下代码1234#!/bin/shcd /Applications/Xcode.app/Contents/Developer/Applications/open -n Simulator.app/ 1sudo sh sim.sh 会有如下提示: 点击OK后,换一个与当前模拟器设备不同的机型 然后在Xcode中选择刚选取的机型run包即可同时打开调试实际上多开别的APP道理也是一样的,进到APP应用目录,open -n appName.app/即可二十七:TableView检测滑动到底部和顶部(可用于聊天界面取历史消息)1234567891011121314- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y == scrollView.contentSize.height - scrollView.frame.size.height) &#123; NSLog(@&quot;滑到底部加载更多&quot;); &#125; if (scrollView.contentOffset.y == 0) &#123; NSLog(@&quot;滑到顶部更新&quot;); &#125;&#125;// 另外点击状态栏会调用- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView&#123; NSLog(@&quot;点击状态栏调用&quot;);&#125; 二十八:区分__weak,__unsafe_unretained,__block123__weak 在释放指针后能够同时将指针置为nil__unsafe_unretained 只留下一个无效的也指针__block 打破循环 copy副本 内部修改]]></content>
      <categories>
        <category>iOS_Objective-C</category>
        <category>iOS_Swift</category>
        <category>Xcode</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
        <tag>Xcode</tag>
        <tag>GitHub</tag>
        <tag>开发小技巧、小功能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS音频开发(录音+播放+剪辑+合成+压缩转码)]]></title>
    <url>%2F2017%2F06%2F21%2FiOS%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91-%E5%BD%95%E9%9F%B3-%E6%92%AD%E6%94%BE-%E5%89%AA%E8%BE%91-%E5%90%88%E6%88%90-%E5%8E%8B%E7%BC%A9%E8%BD%AC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[录音: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//音频会话AVAudioSession *session = [AVAudioSession sharedInstance];NSError *sessionError;/*AVAudioSessionCategoryPlayAndRecord :录制和播放AVAudioSessionCategoryAmbient :用于非以语音为主的应用,随着静音键和屏幕关闭而静音.AVAudioSessionCategorySoloAmbient :类似AVAudioSessionCategoryAmbient不同之处在于它会中止其它应用播放声音。AVAudioSessionCategoryPlayback :用于以语音为主的应用,不会随着静音键和屏幕关闭而静音.可在后台播放声音AVAudioSessionCategoryRecord :用于需要录音的应用,除了来电铃声,闹钟或日历提醒之外的其它系统声音都不会被播放,只提供单纯录音功能.*/[session setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;sessionError];[session setActive:YES error:nil];// 录音参数NSDictionary *setting = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kAudioFormatLinearPCM], AVFormatIDKey,// 编码格式 [NSNumber numberWithFloat:8000], AVSampleRateKey, //采样率 [NSNumber numberWithInt:2], AVNumberOfChannelsKey, //通道数 [NSNumber numberWithInt:16], AVLinearPCMBitDepthKey, //采样位数(PCM专属) [NSNumber numberWithBool:NO], AVLinearPCMIsNonInterleaved, //是否允许音频交叉(PCM专属) [NSNumber numberWithBool:NO],AVLinearPCMIsFloatKey, //采样信号是否是浮点数(PCM专属) [NSNumber numberWithBool:NO], AVLinearPCMIsBigEndianKey, //是否是大端存储模式(PCM专属) [NSNumber numberWithInt:AVAudioQualityMax], AVEncoderAudioQualityKey, //音质 nil];self.audioRecorder.delegate = self;//开启音频测量self.audioRecorder.meteringEnabled = YES;//保存路径self.audioRecorder = [[AVAudioRecorder alloc] initWithURL:[NSURL URLWithString:filePath] settings:setting error:nil];//准备 / 开始录音[self.audioRecorder prepareToRecord];[self.audioRecorder record];//暂停录音[self.audioRecorder pause];//停止录音[self.audioRecorder stop];//删除录音//AVAudioRecorderDelegate//when a recording has been finished or stopped. This method is NOT called if the recorder is stopped due to an interruption.(录音完成)- (void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder successfully:(BOOL)flag;//if an error occurs while encoding it will be reported to the delegate(编码发生错误)- (void)audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)recorder error:(NSError * __nullable)error;//when the audio session has been interrupted while the recorder was recording. The recorded file will be closed.(被打断)- (void)audioRecorderBeginInterruption:(AVAudioRecorder *)recorder NS_DEPRECATED_IOS(2_2, 8_0);//when the audio session interruption has ended and this recorder had been interrupted while recording(被打断结束)- (void)audioRecorderEndInterruption:(AVAudioRecorder *)recorder withOptions:(NSUInteger)flags NS_DEPRECATED_IOS(6_0, 8_0); 播放123456789101112131415161718192021222324252627282930313233343536373839AVAudioSession *session = [AVAudioSession sharedInstance];NSError *sessionError;[session setCategory:AVAudioSessionCategoryPlayback error:&amp;sessionError];[session setActive:YES error:nil];//开启接近监视(靠近耳朵的时候听筒播放,离开的时候扬声器播放)[[UIDevice currentDevice] setProximityMonitoringEnabled:YES];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(sensorStateChange:)name:UIDeviceProximityStateDidChangeNotification object:nil];self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL URLWithString:filePath] error:nil];self.audioPlayer.delegate = self;//准备播放 / 播放[self.audioPlayer prepareToPlay];[self.audioPlayer play];//停止播放[self.audioPlayer stop];//暂停播放[self.audioPlayer pause];//proximityStateChange:(NSNotificationCenter *)notification方法if ([[UIDevice currentDevice] proximityState] == YES) &#123; //靠近耳朵 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];&#125; else &#123; //离开耳朵 [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:nil];&#125;//AVAudioPlayerDelegate//when a sound has finished playing. This method is NOT called if the player is stopped due to an interruption(播放完成)- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag;//if an error occurs while decoding it will be reported to the delegate.(解码结束)- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError * __nullable)error;//when the audio session has been interrupted while the player was playing. The player will have been paused(被打断)- (void)audioPlayerBeginInterruption:(AVAudioPlayer *)player NS_DEPRECATED_IOS(2_2, 8_0);//when the audio session interruption has ended and this player had been interrupted while playing(被打断结束)- (void)audioPlayerEndInterruption:(AVAudioPlayer *)player withOptions:(NSUInteger)flags NS_DEPRECATED_IOS(6_0, 8_0); 剪辑将路径filePath下的音频文件从time截取到time2后在resultPath中输出123456789101112//AVURLAsset是AVAsset的子类,AVAsset类专门用于获取多媒体的相关信息,包括获取多媒体的画面、声音等信息.而AVURLAsset子类的作用则是根据NSURL来初始化AVAsset对象.AVURLAsset *videoAsset = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:filePath]];//音频输出会话//AVAssetExportPresetAppleM4A: This export option will produce an audio-only .m4a file with appropriate iTunes gapless playback data(输出音频,并且是.m4a格式)AVAssetExportSession *exportSession = [AVAssetExportSession exportSessionWithAsset:videoAsset presetName:AVAssetExportPresetAppleM4A];//设置输出路径 / 文件类型 / 截取时间段exportSession.outputURL = [NSURL fileURLWithPath:resultPath];exportSession.outputFileType = AVFileTypeAppleM4A;exportSession.timeRange = CMTimeRangeFromTimeToTime(CMTimeMake(time1, 1), CMTimeMake(time2, 1));[exportSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 合成将路径filePath1和路径filePath2下的音频合成12345678910111213141516171819//AVURLAsset子类的作用则是根据NSURL来初始化AVAsset对象.AVURLAsset *videoAsset1 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath1] options:nil];AVURLAsset *videoAsset2 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath2] options:nil];//音频轨迹(一般视频至少有2个轨道,一个播放声音,一个播放画面.音频有一个)AVAssetTrack *assetTrack1 = [[videoAsset1 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];AVAssetTrack *assetTrack2 = [[videoAsset2 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];//AVMutableComposition用来合成视频或音频AVMutableComposition *composition = [AVMutableComposition composition];AVMutableCompositionTrack *compositionTrack = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];// 把第二段录音添加到第一段后面[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset1.duration) ofTrack:assetTrack1 atTime:kCMTimeZero error:nil];[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset2.duration) ofTrack:assetTrack2 atTime:videoAsset1.duration error:nil];//输出AVAssetExportSession *exporeSession = [AVAssetExportSession exportSessionWithAsset:composition presetName:AVAssetExportPresetAppleM4A];exporeSession.outputFileType = AVFileTypeAppleM4A;exporeSession.outputURL = [NSURL fileURLWithPath:resultPath];[exporeSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 压缩转码下载LAME (Lame Aint an MP3 Encoder) 双击解压后放到一个文件夹下,文件夹需要命名为lame,否则无法生成.h和.a文件使用Terminal进入该文件夹,编译生成静态库,脚本代码1234567$:cd cd /Users/mac/Desktop/lame//创建build_lame.sh$:touch build_lame.sh//打开build_lame.sh,粘贴脚本代码$:open build_lame.sh//编译执行脚本,生成静态库,需要输入本机密码$:sudo sh build_lame.sh 将fat-lame文件夹下的include文件夹和lib文件夹放入工程,再写一个OC的类调用lame.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@try &#123; int read, write; FILE *pcm = fopen([filePath cStringUsingEncoding:1], &quot;rb&quot;);//被转换的音频文件位置 fseek(pcm, 4*1024, SEEK_CUR); FILE *mp3 = fopen([resultPath cStringUsingEncoding:1], &quot;wb&quot;);//生成的Mp3文件位置 const int PCM_SIZE = 8192; const int MP3_SIZE = 8192; short int pcm_buffer[PCM_SIZE*2]; unsigned char mp3_buffer[MP3_SIZE]; // 初始化lame编码器 lame_t lame = lame_init(); // 设置lame mp3编码的采样率 / 声道数 / 比特率 lame_set_in_samplerate(lame, 8000); lame_set_num_channels(lame,2); lame_set_out_samplerate(lame, 8000); lame_set_brate(lame, 8); // MP3音频质量.0~9.其中0是最好,非常慢,9是最差. lame_set_quality(lame, 7); // 设置mp3的编码方式 lame_set_VBR(lame, vbr_default); lame_init_params(lame); do &#123; size_t size = (size_t)(2 * sizeof(short int)); read = fread(pcm_buffer, size, PCM_SIZE, pcm); if (read == 0) &#123; write = lame_encode_flush(lame, mp3_buffer, MP3_SIZE); &#125; else &#123; write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, MP3_SIZE); &#125; fwrite(mp3_buffer, write, 1, mp3); &#125; while (read != 0); lame_close(lame); fclose(mp3); fclose(pcm);&#125;@catch (NSException *exception) &#123; NSLog(@&quot;%@&quot;,[exception description]);&#125;@finally &#123; // 转码完成 return resultPath;&#125; 基本上可以将100K左右的录音文件压缩到10K以下]]></content>
      <categories>
        <category>iOS_Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>音频开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一步一步教你理解和实现iOS中的链式编程和函数式编程]]></title>
    <url>%2F2017%2F06%2F21%2F%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%95%99%E4%BD%A0%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E7%8E%B0iOS%E4%B8%AD%E7%9A%84%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谈到链式编程和函数式编程,那Masonry几乎就是最经典的代表.如:1make.top.equalTo(self.view).offset(60) 像这样top.equalTo(self.view).offset(60)通过”点”语法，将需要执行的代码块连续的书写下去,就是链式编程.它能使代码简单易读，书写方便像这样equalTo(self.view)通过’()’去调用函数,一般调用完返回的还是这个对象本身,就是函数式编程. 1.传统写法,两个方法需要单独调用,也不能任意组合顺序创建Person类123456789101112131415Person.h:- (void)eat1;- (void)sleep1;Person.m:- (void)eat1&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125;- (void)sleep1&#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; 控制器中调用Person类中方法12345ViewController.m:Person *person = [[Person alloc] init];[person eat1];[person sleep1]; 2.用’[]’实现连续调用12345678910111213141516171819202122Person.h:- (Person *)eat2;- (Person *)sleep2;Person.m:- (Person *)eat2&#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self;&#125;- (Person *)sleep2&#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self;&#125;ViewController.m:[[person eat2] sleep2];[[person sleep2] eat2]; 3.用’()”实现函数式编程,用block实现1234567891011121314151617181920212223242526Person.h:- (void (^)())eat3;- (void (^)())sleep3;Person.m:- (void (^)())eat3&#123; //定义block void (^eat3Block)() = ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); &#125;; return eatBlock;&#125;- (void (^)())sleep3&#123; return ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); &#125;;;&#125;ViewController.m:person.eat3();person.sleep3(); 4.实现函数式 + 链式(无参)12345678910111213141516171819202122232425262728Person.h:- (Person * (^)())eat4;- (Person * (^)())sleep4;Person.m:- (Person *(^)())eat4&#123; Person * (^eat4Block)() = ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self; &#125;; return eat4Block;&#125;//上下两种写法一样- (Person *(^)())sleep4&#123; return ^ &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return self; &#125;;&#125;ViewController.m:person.eat4().sleep4();person.sleep4().eat4(); 5.实现函数式 + 链式(带参)12345678910111213141516171819202122232425262728Person.h:- (Person * (^)(NSString *foodName))eat5;- (Person * (^)(NSInteger hour))sleep5;Person.m:- (Person *(^)(NSString *))eat5&#123; Person * (^eat5Block)() = ^(NSString *foodName) &#123; NSLog(@&quot;吃: %@&quot;,foodName); return self; &#125;; return eat5Block;&#125;//上下两种写法一样- (Person *(^)(NSInteger))sleep5&#123; return ^(NSInteger hour) &#123; NSLog(@&quot;睡了%ld小时&quot;,(long)hour); return self; &#125;;&#125;ViewController.m:person.eat5(@&quot;蛋糕&quot;).sleep5(8);person.sleep5(8).eat5(@&quot;面包&quot;);]]></content>
      <categories>
        <category>iOS_Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>链式编程和函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>